# 廖雪峰的JavaScript教程

在线教程地址：[JavaScript教程](https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)

## 函数
### 函数的定义和调用 

### 变量作用域与解构赋值
* 作用域
   * 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量；
   * 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响；
   * 嵌套函数，内部函数可以访问外部函数定义的变量，反过来则不行；
    
      ```javascript
      function foo() {
          var x = 1;
          function bar() {
              var y = x + 1; // bar可以访问foo的变量x!
          }
          var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
      }
      ```
    
   * 函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。
   
      ```javascript
      function foo() {
          var x = 1;
          function bar() {
              var x = 'A';
              console.log('x in bar() = ' + x); // 'A'
          }
          console.log('x in foo() = ' + x); // 1
          bar();
      }
      
      foo();
      ```
      
* 变量提升
   * 变量的声明提升但是变量的值不会提升
   * 在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。常见的做法是用一个var申明函数内部用到的所有变量：
      
      ```javascript
      function foo() {
          var
              x = 1, // x初始化为1
              y = x + 1, // y初始化为2
              z, i; // z和i为undefined
          // 其他语句:
          for (i=0; i<100; i++) {
              // ...
          }
      }
      ```
      
* 全局作用域
   * 全局作用域的变量实际上被绑定到window的一个属性
   * 任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。
* 名字空间
   * 为了防止命名冲突，将所有变量和函数全部绑定到一个全局变量中
   * 如：Jquery
* 局部作用域
   * 关键字let，用let替代var可以申明一个块级作用域的变量
* 常量  
   * 关键字const，不可更改、块级作用域
* 解构赋值  -- ES6新用法，比较常用
   * 对数组元素进行解构赋值时，多个变量要用`[...]`括起来
   * 需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性
      
      ```javascript
      'use strict';
      
      var person = {
        name: '小明',
        age: 20,
        gender: 'male',
        passport: 'G-12345678',
        school: 'No.4 middle school'
      };
      var {name, age, passport} = person;
      ```
   * 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的;
   * 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。
     如果要使用的变量名和属性名不一致，可以用下面的语法获取：

      ```javascript
      var person = {
          name: '小明',
          age: 20,
          gender: 'male',
          passport: 'G-12345678',
          school: 'No.4 middle school',
          address: {
              city: 'Beijing',
              street: 'No.1 Road',
              zipcode: '100001'
          }
      };
      var {name, address: {city, zip}} = person;
      name; // '小明'
      city; // 'Beijing'
      zip; // undefined, 因为属性名是zipcode而不是zip
      // 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
      address; // Uncaught ReferenceError: address is not defined
      ``` 
      
   * 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：

      ```javascript
      var person = {
          name: '小明',
          age: 20,
          gender: 'male',
          passport: 'G-12345678'
      };
      
      // 如果person对象没有single属性，默认赋值为true:
      var {name, single=true} = person;
      name; // '小明'
      single; // true
      ```

   * 如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：

      ```javascript
      // 声明变量:
      var x, y;
      // 解构赋值:
      {x, y} = { name: '小明', x: 100, y: 200};
      // 语法错误: Uncaught SyntaxError: Unexpected token =
      
      
      // js引擎把 { 开头的语句当作了块处理，于是 = 不再合法。解决方法是用小括号括起来：
      ({x, y} = { name: '小明', x: 100, y: 200});
      ```
   * 一个函数接收一个对象作为参数，可以使用解构直接把对象的属性绑定到变量中

      ```javascript
      function buildDate({year, month, day, hour=0, minute=0, second=0}) {
          return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);
      }
 
      buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 });
      // Sun Jan 01 2017 20:15:00 GMT+0800 (CST)
      ```
       
### 函数的方法
* 在一个方法内部，this是一个特殊变量，它始终指向当前对象。
* 在非strict模式下，this重新指向全局对象window。
* 在strict模式下让函数的this指向undefined。

```javascript
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined


// 修正方法  用that变量首先捕获this
'use strict';

var xiaoming2 = {
  name: '小明',
  birth: 1990,
  age: function () {
    var that = this; // 在方法内部一开始就捕获this
    function getAgeFromBirth() {
      var y = new Date().getFullYear();
      return y - that.birth; // 用that而不是this
    }
    return getAgeFromBirth();
  }
};

console.log(xiaoming2.age()); // 28
```


* 修改this的指向
   * `apply(obj, [])` : 要指定函数的this指向哪个对象，可以用函数本身的apply方法，
   它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。
   
   ```javascript
    function getAge() {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
    
    var xiaoming = {
        name: '小明',
        birth: 1990,
        age: getAge
    };
    
    xiaoming.age(); // 25
    getAge.apply(xiaoming, []); // 28, this指向xiaoming, 参数为空
    ```
  
   * `call`：与apply类似，唯一区别：call()是把把参数按顺序传入
     对普通函数调用，我们通常把this绑定为null
     
    ```javascript
    'use strict';
    
    var count = 0;
    var oldParseInt = parseInt; // 保存原函数
    
    window.parseInt = function () {
      count += 1;
      return oldParseInt.apply(null, arguments); // 调用原函数
    };
  
    // 测试:
    parseInt('10');
    parseInt('20');
    parseInt('30');
    console.log('count = ' + count); // 3
    ``` 

## 高阶函数
一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

### map
* `map()` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

  ```javascript
  // ES6
  let numbers = [1, 5, 10, 15];
  let doubles = numbers.map( x => x ** 2);
  
  // doubles is now [1, 25, 100, 225]
  ```

* 可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：

  ```javascript
  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
  ```

### reduce
* `reduce()`把一个函数作用在这个Array的`[x1, x2, x3...]`上，这个函数必须接收两个参数，
`reduce()`把结果继续和序列的下一个元素做累积计算。

```javascript
// 把一个字符串13579先变成Array——[1, 3, 5, 7, 9]，
// 再利用reduce()就可以写出一个把字符串转换为Number的函数。

function string2int(s) {
  return s.split('').map(function (x){ return +x;}).reduce(function (x,y){return x * 10 + y;});
}
```
* 来个应用

```javascript
// 请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。
// 输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。
function normalize(arr) {
  return arr.map(function (name) {return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();});
}
```

### filter
* 用于把Array的某些元素过滤掉，返回剩下的元素
* 和`map()`类似，Array的`filter()`也接收一个函数。和`map()`不同的是，
`filter()`把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。
* `filter()`接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。
回调函数还可以接收另外两个参数，表示元素的位置和数组本身：

```javascript
var arr = ['A', 'B', 'C'];
var r = arr.filter(function (element, index, self) {
    console.log(element); // 依次打印'A', 'B', 'C'
    console.log(index); // 依次打印0, 1, 2
    console.log(self); // self就是变量arr
    return true;
});
```

利用此属性可以巧妙地进行数组的去重。
```javascript
var 
    r,
    arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];

r = arr.filter(function (element, index, self) { 
  return self.indexOf(element) === index;
 })
 
console.log(r.toString());  // apple,strawberry,banana,pear,orange

// 原理： 去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。
```

利用filter删选素数
```javascript
function get_primes(arr) {
  return arr.filter(function(x) {
    if (x <= 1) {
      return false;
    }

    for (let i = 2; i < x; i++) {
      if (x % i === 0) {
        return false;
      }
    }
    
    return true;
  });
}



// 测试:
var
  x,
  r,
  arr = [];
for (x = 1; x < 100; x++) {
  arr.push(x);
}
r = get_primes(arr);
if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) {
  console.log('测试通过!');
} else {
  console.log('测试失败: ' + r.toString());
}
```

### sort
* Array的`sort()`方法默认把所有元素先转换为String再排序

```javascript
// 无法理解的排序规则
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]

// 优化排序
var arr = [10, 20, 1, 2];
arr.sort(function (a, b) { 
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  
  return 0;
})
console.log(arr); // [1, 2, 10, 20]  正序排列
```

* 忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。
* `sort()`方法会直接对Array进行修改，它返回的结果仍是当前Array(原数组已经被排序后的数组代替)

```javascript
var a1 = ['B', 'A', 'C'];
var a2 = a1.sort();
a1; // ['A', 'B', 'C']
a2; // ['A', 'B', 'C']
a1 === a2; // true, a1和a2是同一对象
```


## 闭包

## 箭头函数

## generator
hah