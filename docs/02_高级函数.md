# 廖雪峰的JavaScript教程

在线教程地址：[JavaScript教程](https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)

## 函数
### 函数的定义和调用 

### 变量作用域与解构赋值
* 作用域
   * 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量；
   * 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响；
   * 嵌套函数，内部函数可以访问外部函数定义的变量，反过来则不行；
    
      ```javascript
      function foo() {
          var x = 1;
          function bar() {
              var y = x + 1; // bar可以访问foo的变量x!
          }
          var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
      }
      ```
    
   * 函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。
   
      ```javascript
      function foo() {
          var x = 1;
          function bar() {
              var x = 'A';
              console.log('x in bar() = ' + x); // 'A'
          }
          console.log('x in foo() = ' + x); // 1
          bar();
      }
      
      foo();
      ```
      
* 变量提升
   * 变量的声明提升但是变量的值不会提升
   * 在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。常见的做法是用一个var申明函数内部用到的所有变量：
      
      ```javascript
      function foo() {
          var
              x = 1, // x初始化为1
              y = x + 1, // y初始化为2
              z, i; // z和i为undefined
          // 其他语句:
          for (i=0; i<100; i++) {
              // ...
          }
      }
      ```
      
* 全局作用域
   * 全局作用域的变量实际上被绑定到window的一个属性
   * 任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。
* 名字空间
   * 为了防止命名冲突，将所有变量和函数全部绑定到一个全局变量中
   * 如：Jquery
* 局部作用域
   * 关键字let，用let替代var可以申明一个块级作用域的变量
* 常量  
   * 关键字const，不可更改、块级作用域
* 解构赋值  -- ES6新用法，比较常用
   * 对数组元素进行解构赋值时，多个变量要用`[...]`括起来
   * 需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性
      
      ```javascript
      'use strict';
      
      var person = {
        name: '小明',
        age: 20,
        gender: 'male',
        passport: 'G-12345678',
        school: 'No.4 middle school'
      };
      var {name, age, passport} = person;
      ```
   * 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的;
   * 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。
     如果要使用的变量名和属性名不一致，可以用下面的语法获取：

      ```javascript
      var person = {
          name: '小明',
          age: 20,
          gender: 'male',
          passport: 'G-12345678',
          school: 'No.4 middle school',
          address: {
              city: 'Beijing',
              street: 'No.1 Road',
              zipcode: '100001'
          }
      };
      var {name, address: {city, zip}} = person;
      name; // '小明'
      city; // 'Beijing'
      zip; // undefined, 因为属性名是zipcode而不是zip
      // 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
      address; // Uncaught ReferenceError: address is not defined
      ``` 
      
   * 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：

      ```javascript
      var person = {
          name: '小明',
          age: 20,
          gender: 'male',
          passport: 'G-12345678'
      };
      
      // 如果person对象没有single属性，默认赋值为true:
      var {name, single=true} = person;
      name; // '小明'
      single; // true
      ```

   * 如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：

      ```javascript
      // 声明变量:
      var x, y;
      // 解构赋值:
      {x, y} = { name: '小明', x: 100, y: 200};
      // 语法错误: Uncaught SyntaxError: Unexpected token =
      
      
      // js引擎把 { 开头的语句当作了块处理，于是 = 不再合法。解决方法是用小括号括起来：
      ({x, y} = { name: '小明', x: 100, y: 200});
      ```
   * 一个函数接收一个对象作为参数，可以使用解构直接把对象的属性绑定到变量中

      ```javascript
      function buildDate({year, month, day, hour=0, minute=0, second=0}) {
          return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);
      }
 
      buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 });
      // Sun Jan 01 2017 20:15:00 GMT+0800 (CST)
      ```
       
### 函数的方法
* 在一个方法内部，this是一个特殊变量，它始终指向当前对象。
* 在非strict模式下，this重新指向全局对象window。
* 在strict模式下让函数的this指向undefined。

```javascript
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined


// 修正方法  用that变量首先捕获this
'use strict';

var xiaoming2 = {
  name: '小明',
  birth: 1990,
  age: function () {
    var that = this; // 在方法内部一开始就捕获this
    function getAgeFromBirth() {
      var y = new Date().getFullYear();
      return y - that.birth; // 用that而不是this
    }
    return getAgeFromBirth();
  }
};

console.log(xiaoming2.age()); // 28
```


* 修改this的指向
   * `apply(obj, [])` : 要指定函数的this指向哪个对象，可以用函数本身的apply方法，
   它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。
   
   ```javascript
    function getAge() {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
    
    var xiaoming = {
        name: '小明',
        birth: 1990,
        age: getAge
    };
    
    xiaoming.age(); // 25
    getAge.apply(xiaoming, []); // 28, this指向xiaoming, 参数为空
    ```
  
   * `call`：与apply类似，唯一区别：call()是把把参数按顺序传入
     对普通函数调用，我们通常把this绑定为null
     
    ```javascript
    'use strict';
    
    var count = 0;
    var oldParseInt = parseInt; // 保存原函数
    
    window.parseInt = function () {
      count += 1;
      return oldParseInt.apply(null, arguments); // 调用原函数
    };
  
    // 测试:
    parseInt('10');
    parseInt('20');
    parseInt('30');
    console.log('count = ' + count); // 3
    ``` 

## 高阶函数
一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。